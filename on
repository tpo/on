#!/bin/bash
## -------------------------------------------------------------------------
# Autor:    Tomas Pospisek
# Revision 1.9 went into git
# -------------------------------------------------------------------------

# -------------------------------------------------------------------------
# usage
# -------------------------------------------------------------------------

[ "$DEBUG" ] && set -x

function usage() {
   cat<<EOH
SYNOPSIS
  on [options] host_list [as remote_user] command
  on           host_list                  list
  
  COMMANDS
    do    "some; commands and -options"
    get   /remote/file [/local/file]
    put   /local/file [/remote/file]
    exec  /local/file ["some args"]*
    term
    list

DESCRIPTION

    on executes "command" on one or more hosts defined by host_list.
   
    host_list is a list of host names separated by spaces and enclosed
    in parenthesis. A host_list can also contain host_groups which will
    be expanded first. A host_group declaration will override a host of
    the same name. See CONFIGURATION below for host_group.
   
    The hosts can not be named "as", "do", "get", "put", "exec", "term",
    "list". In case you use such names you need to alias them through
    a host_group.

    The command is allways executed sequentially, one host after the other.

    remote_user is not allowed to contain any metacharacters such as spaces.

    on is only really usefull if you distribute your ssh key to the
    target hosts.

COMMANDS
    do    will execute the commands and parameters passed to the
          command as last parameter on the remote machines

    get   will copy the /remote/file from the given remote machines
          onto the local machine. If /local/file is not given, then
          the file will be copied to the same path as the remote file is.

          Relative remote/file paths will be copied to relative paths
          *starting from the current working directory*, same as scp would.

          The files will be given a postfix consisting of the name of the
          host the were fetched from.

    put   will copy the /local/file to given remote machines. If
          /remote/file is not given, then the file will be copied to
          the same path as /local/file. Since we're using scp to do
          the copying, giving a /local/file with a relative path and
          omitting the /remote/file the file will be put into the
          relative path starting from the HOME directory!

    exec  will execute the given local file with the arguments that
          follow on the remote machines

    list  will resolve the hosts - that is list the machines that
          are part of the host_list. Useful for debugging your config.

    term  will open a terminal (shell) on each remote machine

OPTIONS
    -v be verbose on what on is doing (on which hosts!)

    -i interactive - stdin from the terminal will be forwarded to the
       remote session. Only available with the "exec" and "do" commands.

    -f (as in force) ignore errors when executing the "do", "get", "put"
       or "exec" commands. Just continue on the next host. Default is to
       abort on error.

    -p prefix all output with hostname. Default is to display the output
       (stdout) unchanged. This option does not apply to the "get" and
       "put" commands.

CONFIGURATION
    on will source ~/.on.config on startup. There you can define variables
    that define host_groups. If your f.ex have a ~/.on.config that contains:

        my_servers="server1 server2"

    then you can call on like this:

	on my_servers do ls

    Since ~/.on.config is being sourced, you use bash scripting there at will
    f.ex. to define groups of groups etc.

    Note that the my_servers declatation will override a possibly existing
    host with the strange name "my_servers".

ENVIRONMENT
    Setting DEBUG will execute on with the -x bash flag set.

AUTHOR
    Tomas Pospisek <tpo_deb@sourcepole.ch>

EOH
   exit 1
}

# -------------------------------------------------------------------------
# further documentation
# -------------------------------------------------------------------------
# [1] on redirection:
#     http://tldp.org/LDP/abs/html/io-redirection.html
#     http://tldp.org/LDP/abs/html/ioredirintro.html
#     http://www.zsh.org/mla/users/2003/msg00941.html

#--------------------------------------------------------------
# comman line parameters
# global variables that are set once only in the parse_parameters
# function
#--------------------------------------------------------------

be_verbose=
ignore_error=
interactive=
prefix_with_hostname=
host_list=
remote_user=
command=
do_commandline=      # only set with the 'do'                    command
local_file=          #         "         'get', 'put' and 'exec' commands
remote_file=         #         "         'get', 'put' and 'exec' commands

# exec_params is an array
declare -a exec_params
exec_params=         #         "         'exec'          command

#--------------------------------------------------------------
# functions
#--------------------------------------------------------------

# add_to_list "a" "b" -> "a b"
# add_to_list ""  "b" -> "b"
# add_to_list "a" "b" -> "a b"
# add_to_list ""  ""  -> ""
#
function add_to_list() {
   if [ "$1" = "" -o "$2" = "" ]; then
      echo "$1$2"
   else
      echo "$1 $2"
   fi
}

function reset_parameters() {
   be_verbose=false
   ignore_error=false
   interactive=non-interactive
   prefix_with_hostname=false
   host_list=
   remote_user=
   command=
   do_commandline=
   local_file=
   remote_file=
   exec_params=( )
}

function parse_parameters() {
   [ "$1" == "--help" ] && usage
   # parse options
   while [[ "$1" =~ ^- ]]; do 
      case "$1" in
         -v) be_verbose=true;;
         -i) interactive=interactive;;
         -f) ignore_error=true;;
         -p) prefix_with_hostname=true;;
         *)  usage ;;
      esac
      shift
   done
   # read host names
   while true; do 
      case "$1" in
         as|as|do|get|put|exec|term|list)
            break
            ;;
      esac
      host_list=$( add_to_list "$host_list" "$1" )
      shift
   done
   if [ "$1" == "as" ]; then
      shift
      remote_user="$1"
      shift
   fi
   command=$1
   shift
   case "$command" in
      do)
         do_commandline="$1" ;;
      get)
         remote_file="$1"
         shift
         local_file="$1"
         if [ ! "$local_file" ]; then
            local_file="$remote_file"
         fi
         ;;
      put)
         local_file="$1"
         shift
         remote_file="$1"
         if [ ! "$remote_file" ]; then
            remote_file="$local_file"
         fi
         ;;
      exec)
         local_file="$1"
         shift
         exec_params=( "$@" ) # array copy
         ;;
      list)
         ;;
      term)
         ;;
      *)
         usage ;;
   esac
   # debug_parameters
}

# prefix output with hostname if so configured
#
function prefix_with() {
   local hostname="$1"

   if [ "$prefix_with_hostname" == "true" ]; then
      awk '{ print "'${hostname}': " $0 }'
   else
      cat
   fi
}

# by default aborts if an error happens when doing something on a remote
# host. If user requests not aborting with -f switch nothing will happen.
#
function on_error() {
   local host="$1"
   local err_status="$2"

   if [ "$err_status" -ne "0" -a "$ignore_error" = "false" ]; then
      echo "Aborting due to error on host ${host} (exit status ${err_status})" >&2
      exit $err_status
   fi
}

# do_remote host_list remote_user
#           "non-interactive"|"interactive"
#           commandline
#
# execute commandline on all hosts in host_list
# with user remote_user. Open connection in "terminal mode"
# if the third parameter is set as 'interactive'
#
# Ex:
#
#    do_remote "mail1 mail2" anonymousCoward non-interactive "cat /etc/shadow"
#    do_remote "webserver" root interactive "dpkg-reconfigure apache2"
#
function do_remote() {
   local host_list="$1"
   local remote_user="$2"
   local interactive="$3"
   local commandline="$4"

   local login_as=
   [ $remote_user ] && login_as="${remote_user}@"

   local terminal=
   [ "$interactive" == "interactive" ] && terminal="-t"

   exec 3>&1 # save original stdout into fd 3
   exec 4>&2 # save original stderr into fd 4, see [1]

   for host in $host_list; do
      debug "Executing: ssh ${login_as}${host} \"$commandline\""
      ssh $terminal ${login_as}${host} "$commandline" \
          > >( prefix_with $host >&3 )                \
         2> >( prefix_with $host >&4 )
      # todo $? was $err_state before?
      on_error $host $?
   done
}

# put_on_remote host_list remote_user local_file remote_file
#
# copy local_file to remote_file on all hosts in
# host_list with user remote_user
#
# Ex:
#
#    put_on_remote "sun" bjoy fuse /tmp/fuse
#
function put_on_remote() {
   local host_list="$1"
   local remote_user="$2"
   local local_file="$3"
   local remote_file="$4"

   local login_as=
   [ $remote_user ] && login_as="${remote_user}@"

   for host in $host_list; do
      debug "Executing: scp \"$local_file\" \"${login_as}${host}:${remote_file}\""
      scp "$local_file" "${login_as}${host}:${remote_file}"
      on_error $host $?
   done
}

# get_from_remote host_list remote_user remote_file local_file
#
# copy remote_file from all hosts in host_list with
# remote_user to local_file_$hostname
#
# Ex:
#
#    get_from_remote "mil" root /etc/passwd passwd
#
function get_from_remote() {
   local host_list="$1"
   local remote_user="$2"
   local remote_file="$3"
   local local_file="$4"

   local login_as=
   [ $remote_user ] && login_as="${remote_user}@"

   for host in $host_list; do
      debug "Executing: scp \"${login_as}${host}:${remote_file}\" \"${local_file}_${host}\""
      scp "${login_as}${host}:${remote_file}" "${local_file}_${host}"
      on_error $host $?
   done
}

# exec_remote host_list remote_user            \
#             "non-interactive"|"interactive"  \
#             local_file exec_params*
#
# copy local_file to all hosts in host_list with user
# remote_user and execute the file there with arguments exec_params.
# Open connection in "terminal mode" if the third parameter is set as
# 'interactive'
#
# Ex:
#
#    exec_remote "server1 server2 server3" root interactive  \
#                on switches as admins do ls
#
function exec_remote() {
   local host_list="$1"
   shift
   local remote_user="$1"
   shift
   local interactive="$1"
   shift
   local local_file="$1"
   shift
   # exec_params are in $@ now

   local login_as=
   [ $remote_user ] && login_as="${remote_user}@"

   local terminal=
   [ "$interactive" == "interactive" ] && terminal="-t"

   local file_name=$( basename "$local_file" )

   # see: http://ninjaverification.wordpress.com/2008/12/17/wrapping-ssh-inside-a-script-and-passing-arbitrary-commands-to-another-program/
   for host in $host_list; do
      debug "At ${login_as}${host} remotely executing \"$dir/$file_name\"" "$@"
      dir=$( ssh ${login_as}${host} "mktemp -d" )
      on_error $host $?
      scp -q "$local_file" "${login_as}${host}:$dir/$file_name"
      on_error $host $?
      (
        ssh $terminal ${login_as}${host} "$dir/$file_name" "$@"
	err_stat=$?              # exit inside on_error would only
        on_error $host $err_stat # terminate this subshell, so we
      ) | prefix_with $host      # need to export $err_stat from it
      [ "$err_stat" != "0" ] && exit $err_stat

      ssh ${login_as}${host} "rm -r $dir"
      on_error $host $?
   done
}

# call_term host_list remote_user
#
# open a terminal on one host after the other on each of the hosts in
# host_list
#
# Ex:
#
#    call_term "server1 server2 server3" as app-admin
#
function call_term() {
   local host_list="$1"
   local remote_user="$2"

   local login_as=
   [ $remote_user ] && login_as="${remote_user}@"

   for host in $host_list; do
      debug "Opening terminal for ${login_as}${host}"
      (
        ssh -t ${login_as}${host}
      ) | prefix_with $host
   done
}

#--------------------------------------------------------------
# functions used for debugging und unit-tests
#--------------------------------------------------------------

function debug() {
   [ "$be_verbose" == "true" ] && echo "$@" >&2
}

function debug_parameters() {
   echo "be_verbose='$be_verbose'"
   echo "ignore_error='$ignore_error'"
   echo "interactive='$interactive'"
   echo "prefix_with_hostname='$prefix_with_hostname'"
   echo "host_list='$host_list'"
   echo "remote_user='$remote_user'"
   echo "command='$command'"
   echo "do_commandline='$do_commandline'"
   echo "local_file='$local_file'"
   echo "remote_file='$remote_file'"
   echo "exec_params='${exec_params[@]}'"
}

function find_hosts() {
   local in_host_list="$1"
   local out_host_list
   local host

   while [ "$in_host_list" != "" ]; do
      host=$(           echo "$in_host_list" | cut -d" " -f 1    )
      in_host_list=$( echo "$in_host_list" | cut -d" " -f 2- -s)

      # if the user defines a variable with a name
      # that corresponds to the parameter given,
      # then return that evale'd variable
      local aliased_hosts
      # if host contains a '-' then that can't be a valid bash
      # variable aka a host_group and thus it's a host
      if [[ "$host" =~ - ]]; then
         aliased_hosts=''
      else
         aliased_hosts=$( eval echo -n \$$host )
      fi
      if [ "$aliased_hosts" = "" ]; then
         out_host_list=$( add_to_list "$out_host_list" "$host" )
      else
         out_host_list=$( add_to_list "$out_host_list" "$aliased_hosts" )
      fi
   done

   echo "$out_host_list"
}

#--------------------------------------------------------------
# unit tests
# enable by uncommenting run_unit_tests in main
#--------------------------------------------------------------

function run_unit_tests() {
   set -e
   for t in test_parse_parameters_do \
            test_parse_parameters_put \
            test_parse_parameters_get \
            test_parse_parameters_exec \
            test_parse_parameters_singlehost \
            test_parse_parameters_hostlist \
            test_parse_parameters_term; do
      echo -n "running test $t : "
      eval $t
      echo successfull
   done
   exit 0
}

# Generic command lines looks like these:
#
#    on host_list [as remote_user] do   "some; commands and -options"
#    on host_list [as remote_user] get  /remote/file [/local/file]
#    on host_list [as remote_user] put  /local/file  [/remote/file]
#    on host_list [as remote_user] exec /local/file  ["some args"]*
#    on host_list [as remote_user] term
#    on host_list                  list
#
function test_parse_parameters_do() {
   # test 1: on windöz as Administrator do "deltree c:\"
   reset_parameters
   parse_parameters -p windöz as Administrator 'do' 'deltree c:\'
   local res=$( debug_parameters )
   local corr=$( cat<<-EOC
		be_verbose='false'
		ignore_error='false'
		interactive='non-interactive'
		prefix_with_hostname='true'
		host_list='windöz'
		remote_user='Administrator'
		command='do'
		do_commandline='deltree c:\'
		local_file=''
		remote_file=''
		exec_params=''
		EOC
              )
   [ "$res" == "$corr" ]
}

function test_parse_parameters_put() {
   # test 2: on -v gagamachines put faighl1 /paat/faighl2
   reset_parameters
   parse_parameters -v -p gagamachines put faighl1 /paat/faighl2
   res=$( debug_parameters )
   corr=$(cat<<-EOC
		be_verbose='true'
		ignore_error='false'
		interactive='non-interactive'
		prefix_with_hostname='true'
		host_list='gagamachines'
		remote_user=''
		command='put'
		do_commandline=''
		local_file='faighl1'
		remote_file='/paat/faighl2'
		exec_params=''
		EOC
              )
  [ "$res" == "$corr" ]
}

function test_parse_parameters_get() {
   # test 2: on -v gagamachines get faighl1
   reset_parameters
   parse_parameters -v -p gagamachines get faighl1
   res=$( debug_parameters )
   corr=$(cat<<-EOC
		be_verbose='true'
		ignore_error='false'
		interactive='non-interactive'
		prefix_with_hostname='true'
		host_list='gagamachines'
		remote_user=''
		command='get'
		do_commandline=''
		local_file='faighl1'
		remote_file='faighl1'
		exec_params=''
		EOC
              )
  [ "$res" == "$corr" ]
}

function test_parse_parameters_exec() {
   # test 3: on -f zOS exec install_debian --force --really-force
   reset_parameters
   parse_parameters -f zOS exec install_debian --force --really-force
   res=$( debug_parameters )
   corr=$(cat<<-EOC
		be_verbose='false'
		ignore_error='true'
		interactive='non-interactive'
		prefix_with_hostname='false'
		host_list='zOS'
		remote_user=''
		command='exec'
		do_commandline=''
		local_file='install_debian'
		remote_file=''
		exec_params='--force --really-force'
		EOC
              )
  [ "$res" == "$corr" ]
}

function test_parse_parameters_singlehost() {
   # test 4: on -i "(mylaptop)" exec install_debian --force --really-force
   reset_parameters
   parse_parameters -i mylaptop exec install_debian --force --really-force
   res=$( debug_parameters )
   corr=$(cat<<-EOC
		be_verbose='false'
		ignore_error='false'
		interactive='interactive'
		prefix_with_hostname='false'
		host_list='mylaptop'
		remote_user=''
		command='exec'
		do_commandline=''
		local_file='install_debian'
		remote_file=''
		exec_params='--force --really-force'
		EOC
              )
  [ "$res" == "$corr" ]
}

function test_parse_parameters_hostlist() {
   # test 5: on -f -i "(mylaptop myserver)" exec install_debian --force --really-force
   reset_parameters
   parse_parameters -f -i "(mylaptop myserver)" exec install_debian --force --really-force
   res=$( debug_parameters )
   corr=$(cat<<-EOC
		be_verbose='false'
		ignore_error='true'
		interactive='interactive'
		prefix_with_hostname='false'
		host_list='mylaptop myserver'
		remote_user=''
		command='exec'
		do_commandline=''
		local_file='install_debian'
		remote_file=''
		exec_params='--force --really-force'
		EOC
              )
  [ "$res" == "$corr" ]
}

function test_parse_parameters_term() {
   # test 6: on GoogleServers as elite term
   reset_parameters
   parse_parameters GoogleServers as elite term
   res=$( debug_parameters )
   corr=$(cat<<-EOC
		be_verbose='false'
		ignore_error='false'
		interactive='non-interactive'
		prefix_with_hostname='false'
		host_list='GoogleServers'
		remote_user='elite'
		command='term'
		do_commandline=''
		local_file=''
		remote_file=''
		exec_params=''
		EOC
              )
  [ "$res" == "$corr" ]
}

#--------------------------------------------------------------
# main
#--------------------------------------------------------------

# run_unit_tests # uncomment to run them

# include on configuration and settings
[ -e ~/.on.config ] && . ~/.on.config

reset_parameters
parse_parameters "$@"
# resolve host_groups
host_list=$( find_hosts "$host_list" )
case "$command" in
   do)   do_remote       "$host_list" "$remote_user" $interactive "$do_commandline" ;;
   get)  get_from_remote "$host_list" "$remote_user"              "$remote_file" "$local_file" ;;
   put)  put_on_remote   "$host_list" "$remote_user"              "$local_file"  "$remote_file" ;;
   exec) exec_remote     "$host_list" "$remote_user" $interactive "$local_file"  "${exec_params[@]}";;
   list) echo            "$host_list" ;;
   term) call_term       "$host_list" "$remote_user";;
   *)    usage ;;
esac
